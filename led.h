#define LED_BLINK_HI 10      //время свечения в режиме блинк
#define LED_BLINK_LOW 60000  //время несвечения в режиме блинк
//
#define LED_DANGER_HI 200         //время включённого состояния на коротком промежутке (время пика) в режиме тревоги
#define LED_DANGER_LOW 200        //время выключенного состояния на коротком промежутке (время впадины) в режиме тревоги
#define LED_DANGER_LOW_LONG 1000  //время выключенного состояния на длинном промежутке (между сериями пиков и впадин) в режиме тревоги
//
#define LED_SIN_SPEED 15  //пауза между сменами состояния синусоиды

//массив значений y, y=sin(x), x - промежутки времени(LED_SIN_SPEED) в рамках одного периода синуса:
byte sin_tab[256] = {
  127, 130, 133, 136, 139, 142, 145, 148, 151, 154, 157, 160, 164, 166, 169, 172,
  175, 178, 181, 184, 187, 189, 192, 195, 197, 200, 202, 205, 207, 210, 212, 214,
  217, 219, 221, 223, 225, 227, 229, 231, 232, 234, 236, 237, 239, 240, 242, 243,
  244, 245, 246, 247, 248, 249, 250, 251, 251, 252, 252, 253, 253, 253, 253, 253,
  254, 253, 253, 253, 253, 252, 252, 251, 251, 250, 249, 249, 248, 247, 246, 245,
  243, 242, 241, 239, 238, 236, 235, 233, 231, 230, 228, 226, 224, 222, 220, 218,
  215, 213, 211, 209, 206, 204, 201, 199, 196, 193, 191, 188, 185, 182, 180, 177,
  174, 171, 168, 165, 162, 159, 156, 153, 150, 147, 144, 141, 137, 134, 131, 128,
  125, 122, 119, 116, 112, 109, 106, 103, 100, 97, 94, 91, 88, 85, 82, 79,
  76, 73, 71, 68, 65, 62, 60, 57, 54, 52, 49, 47, 44, 42, 40, 38,
  35, 33, 31, 29, 27, 25, 23, 22, 20, 18, 17, 15, 14, 12, 11, 10,
  8, 7, 6, 5, 4, 4, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9,
  10, 11, 13, 14, 16, 17, 19, 21, 22, 24, 26, 28, 30, 32, 34, 36,
  39, 41, 43, 46, 48, 51, 53, 56, 58, 61, 64, 66, 69, 72, 75, 78,
  81, 84, 87, 89, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 127
};

// создаём перечисление modes
// это будут возможные состояния светодиода
enum modes_t {
  LED_OFF,
  LED_BLINK,
  LED_DANGER,
  LED_SIN,
  LED_ALWAYS_ON
};



//======================================РАЗДЕЛ_ОПИСАНИЯ_КЛАССА_LED:====================================== :



class LED {
public:
  //конструктор класса:
  LED(byte pin, modes_t modes, byte danger_level = 0) {
    _pin = pin;
    _modes = modes;
    pinMode(_pin, OUTPUT);
    _danger_level = danger_level;
    _danger_level_save = danger_level;
    _time_stamp = millis();
  }

  //установка режима и количества параметров, значения которых вышли за допустимые пределы:
  void setMode(modes_t modes, byte danger_level = 0) {
    if ((_modes == modes) && (_danger_level_save == danger_level)) {
      return;
    } else {
      _modes = modes;
      _danger_level = danger_level;
      _danger_level_save = danger_level;
    };
  }

  //процедура проверки состояния светодиода и перехода к выполнению соотв. действий:
  void refresh();


private:
  byte _pin;
  //uint32_t _tmr;
  modes_t _modes;
  bool _flag;
  byte _state;              //текущее последнее состояние светодиода (всключён/выключен/в ожидании)
  byte _danger_level;       //текущее значение счётчика опасности (параметров, вышедших за границы допустимых значений)
  byte _danger_level_save;  //сохранение абсолютного значения уровня опасности
  uint32_t _time_stamp;     //время подследнего обновления
  byte _sin_number = 0;     //выводимое значение синуса для LED_SIN

  //процедуры, которые будут использоваться внутри процедуры refresh для реализации режимов светодиода:
  void setmode_LED_BLINK();
  void setmode_LED_DANGER();
  void setmode_LED_SIN();
  void setmode_LED_ALWAYS_ON();
};



//======================================РАЗДЕЛ_ОСНОВНОЙ_ПРОЦЕДУРЫ_refresh()====================================== :



//реализация метода refresh (проверки и запуска обновления светодиода):
void LED::refresh() {
  //кейс по состояниям; в зависимости от состояния выполняем то или иное изменение светодиода ! ЕСЛИ НАСТАЛО ВРЕМЯ!
  switch (_modes) {
    case LED_OFF:
      //нет вызова в процедуре refresh - нет установки значений яркости на светодиод - светодиод выключен.
      break;

    case LED_BLINK:
      //вызов процедуры проверки и установки на светодиод режима маячок (короткая вспышка раз в минуту):
      setmode_LED_BLINK();
      break;

    case LED_DANGER:
      //вызов процедуры проверки и установки светодиода в режиме тревоги (несколько коротких вспышек+ожидание):
      setmode_LED_DANGER();
      break;

    case LED_SIN:
      //вызов процедуры проверки и установки значений синуса на светодиод:
      setmode_LED_SIN();
      break;

    case LED_ALWAYS_ON:
      //вызов процедуры проверки и установки на светодиод режима (всегда включённый светодиод):
      setmode_LED_ALWAYS_ON();
      break;

    default:
      //выход по умолчанию, на всякий случай
      break;
  };
}



//========================================РАЗДЕЛ_РЕЖИМА_МАЯЧОК======================================== :



void LED::setmode_LED_BLINK() {
  //_state - в каком состоянии сейчас находится светодиод - горит (1) или нет (0)

  if (_state == 1) {  //если светодиод включён
    //если не прошло 10 мс горения светодиода:
    if ((millis() - _time_stamp) < LED_BLINK_HI) {
      return;  //выходим из процедуры
    } else {   //выключаем светодиод
      digitalWrite(_pin, 0);
      _state = 0;
      _time_stamp = millis();
      return;
    };
  } else {  //если светодиод выключен
    //если не прошло больше минуты:
    if ((millis() - _time_stamp) < LED_BLINK_LOW) {
      return;  //выходим из процедуры
    } else {   //включаем светодиод
      digitalWrite(_pin, 1);
      _state = 1;
      _time_stamp = millis();
      return;
    };
  };
  return;
}



//========================================РАЗДЕЛ_РЕЖИМА_ТРЕВОГА======================================== :



void LED::setmode_LED_DANGER() {

  if (_state == 1) {
    if ((millis() - _time_stamp) < LED_DANGER_HI) {  //состояние и время включённого режима
      return;                                        //выходим из процедуры
    } else if (_danger_level > 0) {                  //выключаем светодиод
      digitalWrite(_pin, 0);
      _state = 0;
      _danger_level = _danger_level - 1;
      _time_stamp = millis();
      return;
    } else {
      _state = 2;
      _time_stamp = millis();
      return;
    };

  } else if (_state == 0) {
    if ((millis() - _time_stamp) < LED_DANGER_LOW) {  //состояние и время выключенного режима
      return;                                         //выходим из процедуры
    } else if (_danger_level > 0) {                   //включаем светодиод
      digitalWrite(_pin, 1);
      _state = 1;
      //_danger_level = _danger_level - 1;
      _time_stamp = millis();
      return;
    } else {
      _state = 2;
      _time_stamp = millis();
      return;
    };
  } else if (_state == 2) {  //режим ожидания, когда светодиод выключен и нужно ждать 1 секунду
    if ((millis() - _time_stamp) < LED_DANGER_LOW_LONG) {
      return;  //выходим из процедуры
    } else {   //включаем светодиод
      _danger_level = _danger_level_save;
      digitalWrite(_pin, 1);
      _state = 1;
      _time_stamp = millis();
      return;
    };
  };

  return;
}



//========================================РАЗДЕЛ_РЕЖИМА_СИНУС======================================== :



void LED::setmode_LED_SIN() {
  if ((millis() - _time_stamp) < LED_SIN_SPEED) {
    return;  //выходим из процедуры
  } else {
    _sin_number = _sin_number + 1;  //  это ж байт ! можно не проверять на 256
    analogWrite(_pin, sin_tab[_sin_number]);
    _state = 1;
    _time_stamp = millis();
  }
  return;
}



//========================================РАЗДЕЛ_РЕЖИМА_"ВСЕГДА_ВКЛЮЧЁН"======================================== :



void LED::setmode_LED_ALWAYS_ON() {
  //_state - в каком состоянии сейчас находится светодиод - горит (1) или нет (0)

  if (_state == 1) {        //если светодиод включён
    return;                 //выходим, он и должен гореть.
  } else {                  //если светодиод выключен
    digitalWrite(_pin, 1);  //гореть обязан!
    _state = 1;
    return;
  };
  return;
}



//===========================КОНЕЦ_РАЗДЕЛОВ===========================
